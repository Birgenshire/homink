# ═══════════════════════════════════════════════════════════════════════════════
# HOMINK COMMON CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════
# Shared config for all Homink e-ink dashboards. Device-specific files include
# this via packages and provide: device_name, device_ip, and sensor definitions.
#
# Display Sections: Weather (temp, condition, wifi) | Energy (solar, home, EV) |
#                   Gates (3 gates with lock detection) | Footer (refresh time)
#
# Update Strategy: Push (instant on state change) + Poll (15s backup) + Threshold
#                  (temp ≥1°F, solar ≥0.5kW, charging ≥100W) + Forced (30min)
# ═══════════════════════════════════════════════════════════════════════════════

esphome:
  on_boot:
      priority: 200.0
      then:
        - lambda: 'SENSOR_INIT_ALL();'  # X-macro initializes all sensors
        - logger.log: "Boot complete, triggering initial display update..."
        - script.execute: update_screen

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:

api:
  on_client_connected:
    - lambda: |-
        ESP_LOGD("api", "Client %s connected from IP %s", client_info.c_str(), client_address.c_str());
        if (client_info == "Home Assistant") {
          ESP_LOGD("api", "Home Assistant connected");
          id(ha_connected) = true;
        }
  on_client_disconnected:
    - lambda: |-
        ESP_LOGD("api", "Client %s disconnected from IP %s", client_info.c_str(), client_address.c_str());
        if (client_info == "Home Assistant") {
          ESP_LOGD("api", "Home Assistant disconnected");
          id(ha_connected) = false;
          id(last_ha_connection_time) = id(homeassistant_time).now().timestamp;
        }

ota:
  platform: esphome

button:
  - platform: shutdown
    name: "${device_name} - Shutdown"
  - platform: restart
    name: "${device_name} - Restart"
  - platform: template
    name: "${device_name} - Refresh Screen"
    entity_category: config
    on_press:
      - logger.log: "Manual refresh button pressed"
      - script.execute: update_screen

globals:
  - id: data_updated
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: recorded_display_refresh
    type: int
    restore_value: yes
    initial_value: '0'

  - id: tesla_power_factor  # Installation-specific: apparent → real power
    type: float
    restore_value: no
    initial_value: '0.789'

  - id: last_display_refresh_time
    type: long
    restore_value: yes
    initial_value: '0'

  - id: threshold_forced_refresh_interval  # 30 minutes
    type: int
    restore_value: no
    initial_value: '1800'

  - id: ha_connected
    type: bool
    restore_value: no
    initial_value: 'true'

  - id: last_ha_connection_time
    type: long
    restore_value: yes
    initial_value: '0'

script:
  - id: update_screen
    then:
      - lambda: 'id(data_updated) = false;'  # Close race condition window

      # Poll HA for latest values
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: !lambda 'return ISensor::get_ha_entity_list();'

      - delay: 2s  # Wait for HA to respond

      # Cache timestamp and sensor values
      - lambda: |-
          long refresh_time = id(homeassistant_time).now().timestamp;
          id(last_display_refresh_time) = refresh_time;
          id(display_last_update).publish_state(refresh_time);
          ESP_LOGD("main", "Caching values at timestamp: %ld", refresh_time);

      - lambda: 'ISensor::update_all();'
      - component.update: eink_display  # Blocks ~4s
      - lambda: 'id(recorded_display_refresh) += 1;'

# 15-second polling: Push (instant callbacks) + Poll (missed update backup)
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: /15
        then:
          - if:
              condition:
                lambda: 'return id(data_updated) == false;'
              then:
                # Poll HA for sensor updates
                - homeassistant.service:
                    service: homeassistant.update_entity
                    data:
                      entity_id: !lambda 'return ISensor::get_ha_entity_list();'

                - delay: 2s

                # Check all sensors for changes
                - lambda: |-
                    if (ISensor::check_all_for_changes()) {
                      id(data_updated) = true;
                      return;
                    }

                # Forced refresh and HA timeout checks
                - if:
                    condition:
                      lambda: 'return id(data_updated) == false;'
                    then:
                      - lambda: |-
                          long current_time = id(homeassistant_time).now().timestamp;
                          long time_since_last_refresh = current_time - id(last_display_refresh_time);
                          long time_since_last_ha_update = current_time - id(last_ha_connection_time);

                          // HA timeout: no sensor updates for 30 minutes
                          if (id(last_ha_connection_time) > 0 && time_since_last_ha_update >= 1800) {
                            if (id(ha_connected)) {
                              ESP_LOGW("main", "No HA updates for %ld seconds - marking disconnected", time_since_last_ha_update);
                              id(ha_connected) = false;
                            }
                          }

                          // Edge cases
                          if (id(last_display_refresh_time) == 0) return;
                          if (time_since_last_refresh < 0) {
                            ESP_LOGW("main", "Clock went backward - resetting refresh time");
                            id(last_display_refresh_time) = current_time;
                            return;
                          }

                          // Forced refresh every 30 minutes
                          if (time_since_last_refresh >= id(threshold_forced_refresh_interval)) {
                            ESP_LOGD("main", "Forced refresh: %ld seconds elapsed", time_since_last_refresh);
                            id(data_updated) = true;
                          }
              else:
                - logger.log: "Update already pending, skipping poll"

          # Execute refresh if needed
          - if:
              condition:
                lambda: 'return id(data_updated) == true;'
              then:
                - logger.log: "Sensor data updated: Refreshing display..."
                - script.execute: update_screen
              else:
                - logger.log: "No significant changes - skipping refresh"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    - lambda: 'ESP_LOGD("wifi", "WiFi connected");'
  on_disconnect:
    - lambda: |-
        ESP_LOGD("wifi", "WiFi disconnected");
        id(ha_connected) = false;
        id(last_ha_connection_time) = id(homeassistant_time).now().timestamp;

font:
  - file: 'fonts/GothamRnd-Book.ttf'
    id: font_small_book
    size: 18
    bpp: 1

  - file: 'fonts/GothamRnd-Bold.ttf'
    id: font_large_bold
    size: 96
    bpp: 1
    glyphs: [' ', '-', '°', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'C', 'F']

  - file: 'fonts/GothamRnd-Bold.ttf'
    id: font_title
    size: 44
    bpp: 1
    glyphs: ['W', 'E', 'A', 'T', 'H', 'R', 'S', 'O', 'L', 'G', 'N', 'I', 'Y', ' ']

  - file: 'fonts/GothamRnd-Bold.ttf'
    id: font_medium_bold
    size: 32
    bpp: 1

  - file: 'fonts/GothamRnd-Bold.ttf'
    id: font_small_bold
    size: 20
    bpp: 1

  - file: 'fonts/GothamRnd-Book.ttf'
    id: font_name
    bpp: 1
    size: 24

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_large
    size: 84
    bpp: 1
    glyphs:
      - "\U000F0590" # weather-cloudy
      - "\U000F0F2F" # weather-cloudy-alert
      - "\U000F0E6E" # weather-cloudy-arrow-right
      - "\U000F0591" # weather-fog
      - "\U000F0592" # weather-hail
      - "\U000F0F30" # weather-hazy
      - "\U000F0898" # weather-hurricane
      - "\U000F0593" # weather-lightning
      - "\U000F067E" # weather-lightning-rainy
      - "\U000F0594" # weather-night
      - "\U000F0F31" # weather-night-partly-cloudy
      - "\U000F0595" # weather-partly-cloudy
      - "\U000F0F32" # weather-partly-lightning
      - "\U000F0F33" # weather-partly-rainy
      - "\U000F0F34" # weather-partly-snowy
      - "\U000F0F35" # weather-partly-snowy-rainy
      - "\U000F0596" # weather-pouring
      - "\U000F0597" # weather-rainy
      - "\U000F0598" # weather-snowy
      - "\U000F0F36" # weather-snowy-heavy
      - "\U000F067F" # weather-snowy-rainy
      - "\U000F0599" # weather-sunny
      - "\U000F0F37" # weather-sunny-alert
      - "\U000F14E4" # weather-sunny-off
      - "\U000F059A" # weather-sunset
      - "\U000F059B" # weather-sunset-down
      - "\U000F059C" # weather-sunset-up
      - "\U000F0F38" # weather-tornado
      - "\U000F059D" # weather-windy
      - "\U000F059E" # weather-windy-variant
      - "\U000F0026" # alert-circle-outline

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_medium
    size: 42
    bpp: 1
    glyphs:
      - "\U000F0A72" # solar-power
      - "\U000F140C" # lightning-bolt
      - "\U000F02DC" # home
      - "\U000F081A" # door-closed
      - "\U000F081C" # door-open
      - "\U000F033F" # lock-open-variant
      - "\U000F007D" # ev-station
      - "\U000F0079" # battery
      - "\U000F151C" # power-plug-off
      - "\U000F0205" # help-circle

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_small
    size: 20
    bpp: 1
    glyphs:
      - "\U000F091F" # wifi-strength-1
      - "\U000F0922" # wifi-strength-2
      - "\U000F0925" # wifi-strength-3
      - "\U000F0928" # wifi-strength-4
      - "\U000F092D" # wifi-strength-off

binary_sensor:
  - platform: homeassistant
    entity_id: "binary_sensor.aqara_door_and_window_sensor_p2_door_2"
    id: _gate1
    on_state:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(gate1)'

  - platform: homeassistant
    entity_id: "binary_sensor.aqara_door_and_window_sensor_p2_door_3"
    id: _gate2
    on_state:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(gate2)'

  - platform: homeassistant
    entity_id: "binary_sensor.aqara_door_and_window_sensor_p2_door"
    id: _gate3
    on_state:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(gate3)'

text_sensor:
  - platform: homeassistant
    entity_id: "lock.shed_lock"
    id: _lock
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(lock)'

  - platform: homeassistant
    entity_id: "sensor.openweathermap_condition"
    id: _weather
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(weather)'

  - platform: homeassistant
    entity_id: "sensor.tesla_wall_connector_status"
    id: _charger
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(charger)'

sensor:
  - platform: template
    name: "${device_name} - Display Last Update"
    device_class: timestamp
    entity_category: "diagnostic"
    id: display_last_update

  - platform: template
    name: "${device_name} - Recorded Display Refresh"
    accuracy_decimals: 0
    unit_of_measurement: "Refreshes"
    state_class: "total_increasing"
    entity_category: "diagnostic"
    lambda: 'return id(recorded_display_refresh);'

  - platform: homeassistant
    entity_id: sensor.e_ink_refreshes_last_24h
    id: refreshes_last_24h_ha
    internal: false
    name: "${device_name} - Refreshes Last 24h"
    unit_of_measurement: "Refreshes"
    accuracy_decimals: 0
    state_class: "measurement"
    entity_category: "diagnostic"

  - platform: wifi_signal
    name: "${device_name} - WiFi Signal Strength"
    id: _wifi_rssi
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    update_interval: 60s

  - platform: homeassistant
    entity_id: "sensor.birgenshire_temp"
    id: _temperature
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(temperature)'

  - platform: homeassistant
    entity_id: "sensor.birgenshire_solar_power"
    id: _solar_power
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(solar_power)'

  - platform: homeassistant
    entity_id: "sensor.tesla_wall_connector_current_power"
    id: _charging_power
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(charging_power)'

  - platform: homeassistant
    entity_id: "sun.sun"
    attribute: elevation
    id: _sun_elev
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(sun_elev)'

  - platform: homeassistant
    entity_id: "sensor.solar_production_last_24h_2"
    id: _solar_energy
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(solar_energy)'

  - platform: homeassistant
    entity_id: "sensor.home_consumption_last_24h_2"
    id: _home_consumption
    on_value:
      then:
        - lambda: 'SENSOR_UPDATE_CALLBACK(home_consumption)'

color:
  - id: color_bg
    red: 0%
    green: 0%
    blue: 0%
    white: 0%
  - id: color_text
    red: 0%
    green: 0%
    blue: 0%
    white: 100%

spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Waveshare 7.5" e-Paper V2 (800x480, B/W, 7.50inv2)
display:
  - platform: waveshare_epaper
    id: eink_display
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin:
      number: GPIO25
      inverted: true
    reset_pin: GPIO26
    reset_duration: 10ms
    model: 7.50inv2
    update_interval: never
    rotation: 90°
    lambda: |-
      // Helper: Check if nighttime (sun elevation < -6° or 8PM-6AM fallback)
      auto is_nighttime = []() -> bool {
        if (sun_elev.has_state()) return sun_elev.value() < -6.0;
        auto time = id(homeassistant_time).now();
        return (time.hour >= 20 || time.hour < 6);
      };

      // Helper: Check if sunrise/sunset (golden hour: -6° to +6°)
      auto is_sunset = []() -> bool {
        if (sun_elev.has_state()) {
          float elev = sun_elev.value();
          return (elev >= -6.0 && elev <= 6.0);
        }
        return false;
      };

      // Weather icon map - Home Assistant weather conditions
      std::map<std::string, std::string> weather_icon_map {
        // Standard conditions
        {"clear", "\U000F0599"},
        {"clear-night", "\U000F0594"},
        {"cloudy", "\U000F0590"},
        {"cloudy-alert", "\U000F0F2F"},
        {"fog", "\U000F0591"},
        {"hail", "\U000F0592"},
        {"hazy", "\U000F0F30"},
        {"hurricane", "\U000F0898"},
        {"lightning", "\U000F0593"},
        {"lightning-rainy", "\U000F067E"},
        {"night", "\U000F0594"},
        {"night-partly-cloudy", "\U000F0F31"},
        {"partlycloudy", "\U000F0595"},
        {"partly-cloudy", "\U000F0595"},
        {"pouring", "\U000F0596"},
        {"rainy", "\U000F0597"},
        {"snowy", "\U000F0598"},
        {"snowy-heavy", "\U000F0F36"},
        {"snowy-rainy", "\U000F067F"},
        {"sunny", "\U000F0599"},
        {"sunset", "\U000F059A"},
        {"tornado", "\U000F0F38"},
        {"windy", "\U000F059D"},
        // OpenWeatherMap-specific alternatives
        {"clearsky", "\U000F0599"},
        {"clear_day", "\U000F0599"},
        {"clear_night", "\U000F0594"},
        {"few_clouds", "\U000F0595"},
        {"scattered_clouds", "\U000F0595"},
        {"broken_clouds", "\U000F0590"},
        {"shower_rain", "\U000F0597"},
        {"rain", "\U000F0597"},
        {"thunderstorm", "\U000F0593"},
        {"snow", "\U000F0598"},
        {"mist", "\U000F0591"},
        {"drizzle", "\U000F0597"},
        {"smoke", "\U000F0591"},
        {"haze", "\U000F0F30"},
        {"dust", "\U000F0F30"},
        {"ash", "\U000F0591"},
        {"squall", "\U000F059D"},
      };

      // === WEATHER SECTION ===
      it.printf(240, 85, id(font_title), color_text, TextAlign::TOP_CENTER, "WEATHER");

      // WiFi signal indicator (upper right)
      std::string wifi_icon = "\U000F092D";  // Default: off
      if (wifi_rssi.has_state()) {
        float rssi = wifi_rssi.value();
        if (rssi > -50) wifi_icon = "\U000F0928";      // 4 bars
        else if (rssi > -60) wifi_icon = "\U000F0925"; // 3 bars
        else if (rssi > -70) wifi_icon = "\U000F0922"; // 2 bars
        else wifi_icon = "\U000F091F";                 // 1 bar
      }
      it.printf(448, 70, id(font_mdi_small), color_text, TextAlign::TOP_RIGHT, "%s", wifi_icon.c_str());

      // Weather icon with day/night/sunset logic
      if (weather.has_state() && weather.value() != "") {
        std::string condition = weather.value();
        std::string icon_to_use = weather_icon_map.count(condition) > 0
          ? weather_icon_map[condition] : "\U000F0026";  // Alert if unknown

        // Apply time-of-day logic for clear/partly-cloudy
        if (condition == "clear" || condition == "clearsky" || condition == "sunny" ||
            condition == "clear_day" || condition == "clear_night") {
          if (is_sunset()) icon_to_use = "\U000F059A";      // Sunset
          else if (is_nighttime()) icon_to_use = "\U000F0594"; // Moon
        } else if (is_nighttime() && (condition == "partlycloudy" || condition == "partly-cloudy" ||
                                       condition == "few_clouds" || condition == "scattered_clouds" ||
                                       condition == "broken_clouds")) {
          icon_to_use = "\U000F0F31";  // Night partly cloudy
        }

        it.printf(100, 140, id(font_mdi_large), color_text, TextAlign::TOP_CENTER, "%s", icon_to_use.c_str());
      } else {
        it.printf(100, 140, id(font_mdi_large), color_text, TextAlign::TOP_CENTER, "\U000F0026");
      }

      // Temperature
      if (temperature.has_state()) {
        if (temperature.value() >= 100 || temperature.value() <= -10) {
          it.printf(300, 140, id(font_large_bold), color_text, TextAlign::TOP_CENTER, "%.0f°F", temperature.value());
        } else {
          it.printf(300, 140, id(font_large_bold), color_text, TextAlign::TOP_CENTER, "%2.0f°F", temperature.value());
        }
      } else {
        it.printf(300, 140, id(font_large_bold), color_text, TextAlign::TOP_CENTER, "--°F");
      }

      it.line(40, 250, 440, 250, color_text);

      // === ENERGY SECTION ===
      it.printf(240, 268, id(font_title), color_text, TextAlign::TOP_CENTER, "ENERGY");

      // Solar Output
      it.printf(60, 339, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F0A72");
      it.printf(120, 342, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", solar_power.name());
      if (solar_power.has_state()) {
        float current_solar = solar_power.value() < 0 ? 0.0 : solar_power.value();
        it.printf(420, 342, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "%.1f kW", current_solar);
      } else {
        it.printf(420, 342, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "-- kW");
      }

      // Solar 24hr
      it.printf(60, 382, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F140C");
      it.printf(120, 385, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", solar_energy.name());
      if (solar_energy.has_state()) {
        it.printf(420, 385, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "%.0f kWh", solar_energy.value());
      } else {
        it.printf(420, 385, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "-- kWh");
      }

      // Home 24hr
      it.printf(60, 425, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F02DC");
      it.printf(120, 428, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", home_consumption.name());
      if (home_consumption.has_state()) {
        it.printf(420, 428, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "%.0f kWh", home_consumption.value());
      } else {
        it.printf(420, 428, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "-- kWh");
      }

      // EV Charging - prioritize power reading over status (handles status glitches)
      if (charging_power.has_state() && charging_power.value() > 100.0) {
        // Active charging
        it.printf(60, 468, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F007D");
        float real_power_kw = (charging_power.value() * id(tesla_power_factor)) / 1000.0;
        it.printf(420, 471, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "%.1f kW", real_power_kw);
      } else if (charger.has_state() && charger.value() != "unavailable") {
        std::string status = charger.value();
        if (status == "not_connected" || status == "booting") {
          it.printf(60, 468, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F151C");
          it.printf(420, 471, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "-- kW");
        } else if (status == "error") {
          it.printf(60, 468, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "X");
          it.printf(420, 471, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "X");
        } else {
          // Plugged in, not charging
          it.printf(60, 468, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F0079");
          it.printf(420, 471, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "0.0 kW");
        }
      } else {
        // Unavailable
        it.printf(60, 468, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F151C");
        it.printf(420, 471, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "-- kW");
      }
      it.printf(120, 471, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", charging_power.name());

      it.line(40, 503, 440, 503, color_text);

      // === GATES SECTION ===
      it.printf(240, 521, id(font_title), color_text, TextAlign::TOP_CENTER, "GATES");

      // Gate 1
      if (gate1.has_state()) {
        it.printf(60, 592, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT,
          gate1.value() ? "\U000F081C" : "\U000F081A");
        it.printf(420, 595, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT,
          gate1.value() ? "OPEN" : "CLOSED");
      } else {
        it.printf(60, 592, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F0205");
        it.printf(420, 595, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "UNKNOWN");
      }
      it.printf(120, 595, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", gate1.name());

      // Gate 2
      if (gate2.has_state()) {
        it.printf(60, 640, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT,
          gate2.value() ? "\U000F081C" : "\U000F081A");
        it.printf(420, 643, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT,
          gate2.value() ? "OPEN" : "CLOSED");
      } else {
        it.printf(60, 640, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F0205");
        it.printf(420, 643, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "UNKNOWN");
      }
      it.printf(120, 643, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", gate2.name());

      // Gate 3 with lock detection
      if (gate3.has_state() && lock.has_state()) {
        if (gate3.value()) {
          it.printf(60, 688, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F081C");
          it.printf(420, 691, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "OPEN");
        } else if (lock.value() == "unlocked") {
          it.printf(60, 688, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F033F");
          it.printf(420, 691, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "UNLOCKED");
        } else {
          it.printf(60, 688, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F081A");
          it.printf(420, 691, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "CLOSED");
        }
      } else {
        it.printf(60, 688, id(font_mdi_medium), color_text, TextAlign::CENTER_LEFT, "\U000F0205");
        it.printf(420, 691, id(font_medium_bold), color_text, TextAlign::CENTER_RIGHT, "UNKNOWN");
      }
      it.printf(120, 691, id(font_name), color_text, TextAlign::CENTER_LEFT, "%s", gate3.name());

      // === FOOTER ===
      char str[40];
      time_t displayTime;

      if (id(ha_connected)) {
        displayTime = id(last_display_refresh_time);
        if (displayTime > 0) {
          strftime(str, sizeof(str), "%b %d, %Y %I:%M:%S %p", localtime(&displayTime));
          it.printf(240, 721, id(font_small_book), color_text, TextAlign::TOP_CENTER, "Refreshed %s", str);
        } else {
          it.printf(240, 721, id(font_small_book), color_text, TextAlign::TOP_CENTER, "Initializing...");
        }
      } else {
        displayTime = id(last_ha_connection_time);
        if (displayTime > 0) {
          strftime(str, sizeof(str), "%b %d, %Y %I:%M:%S %p", localtime(&displayTime));
          it.printf(240, 721, id(font_small_book), color_text, TextAlign::TOP_CENTER, "Last Seen %s", str);
        } else {
          it.printf(240, 721, id(font_small_book), color_text, TextAlign::TOP_CENTER, "No Connection");
        }
      }
